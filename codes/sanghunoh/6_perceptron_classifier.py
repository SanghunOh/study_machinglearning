# -*- coding: utf-8 -*-
"""6강_선형판별함수_퍼셉트론.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rKIBXgljeqT3FIjNVfcwuRe8qhrIZoLh

#Perceptron
$
y_i=step(w_i^Tx+w_{i0}) \\
step(u) = \{
  \begin{array}{cl}
  1 & \text{if }u>0 \\
  0 & otherwise
  \end{array}
$

#퍼셉트론 이용한 이분류(Perceptron Classifier)

## 학습데이터 생성
"""

import numpy as np

np.random.seed(50)  # 동일한 수열 발생 위해 설정
row_count = 10

rand_std_1 = np.random.randn(row_count, 2)
class_A = rand_std_1

# case 1
mean_2 = np.array([2,2])
# sigma_2 = np.array([[1,1],[1,2]])
sigma_2 = np.array([[3,1],[1,3]])   # 식별 위해 값 분포 임의 폭 증가
rand_std_2 = np.random.randn(row_count, 2)
class_B = rand_std_2 @ np.sqrt(sigma_2) + mean_2

# case 2
# import numpy.matlib
# rand_std_2 = np.random.randn(row_count, 2) + np.matlib.repmat([2.5,2.5],row_count, 1)
# class_B = rand_std_2

class_B.shape

"""### Plot 그리기"""

import matplotlib.pyplot as plt

from matplotlib.markers import MarkerStyle
# plt.plot(class_A[:,0],class_A[:,1],marker='+',linestyle='None') # 데이터 A
# plt.plot(class_B[:,0],class_B[:,1],'v')  # 데이터 B

"""##학습 하기
$
w_i^{τ+1}=w_i^{(τ)}+η(t_i-y_i)x \\
w_{i0}^{τ+1}=w_{i0}^{(τ)}+η(t_i-y_i)x
$
"""

# 입출력 차원
input_dim = 2
output_dim = 1

"""### 임의로 부여한 값으로 결정 경계 표시"""

# 파라미터 초기화
weight=np.random.rand(input_dim,1)*0.4-0.2
weight0=np.random.rand(1)*0.4-0.2
weight, weight0
# np.info(weight)

# merge data
train_data = np.vstack([class_A,class_B])

# 선형 그리기 위한 데이터 생성
train_dataX_min, train_dataX_max = np.min(train_data[:,0],0), np.max(train_data[:,0],0)
import math
math.floor(train_dataX_min), math.ceil(train_dataX_max),

x_values = np.arange(math.floor(train_dataX_min), math.ceil(train_dataX_max))
x_values, np.info(x_values)

x_values, weight, ((weight[0,0]*x_values-weight0)/weight[1,0])

# plt.plot(class_A[:,0],class_A[:,1],marker='+',linestyle='None') # 데이터 A
# plt.plot(class_B[:,0],class_B[:,1],'v')  # 데이터 B
# # x_values가 커서 [1:3] 제한 출력
# plt.plot(x_values[1:3], ((weight[0,0]*x_values-weight0)/weight[1,0])[1:3]) 
# plt.show()

"""### 학습 통한 결정 경계 """

# class별 label 생성. class_A - 0, class_B - 1
class_A_label = np.full((row_count,1), fill_value=0)
class_B_label = np.full((row_count,1), fill_value=1)
class_A_label.shape, class_B_label.shape
train_label = np.vstack([class_A_label, class_B_label])
train_label[row_count-3:row_count+3], np.info(train_label)

# 학습 횟수
steps = 5
eta = 0.5
# plt.plot(class_A[:,0],class_A[:,1],marker='+',linestyle='None') # 데이터 A
# plt.plot(class_B[:,0],class_B[:,1],'v')  # 데이터 B

for j in range(1, steps):
  # errors = np.empty([0,1])
  for i in range(row_count*2):
    x_value, y_label = train_data[i,:], train_label[i,0]
    # 퍼셉트론 계산
    result = x_value @ weight + weight0
    if (result > 0) :
      y_hat=1
    else :
      y_hat=0
    error = y_label - y_hat
    # errors = np.append(errors,error)
    delta_weight = np.reshape(eta * error * x_value.T, (2,1))
    delta_weight0 = eta * error * 1
    weight = weight + delta_weight
    weight0 = weight0 + delta_weight0
  # x_values가 커서 [1:3] 제한 출력
#   plt.plot(x_values[1:3], ((weight[0,0]*x_values-weight0)/weight[1,0])[1:3]) 
# plt.show()

